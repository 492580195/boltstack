
## 问题
不知道大家是如何做宿主更新bolt界面的,我的做法是在宿主的消息循环里判断是否有更新boltUI的函数队列,有的话就执行. 但是鼠标拖动bolt窗体时,宿主的消息循环会暂时被阻塞掉,在停止拖动窗体时继续,这会导致更新UI延迟. 我的临时解决方案是在lua端监听bolt窗体的消息循环,给宿主程序反向注册窗口消息回调. waterflier说也可以通过后台窗体解决,这个做法我不会,有人教下我么?

## 解释
先要理解什么才算是UI线程被阻塞，UI线程之所以为UI线程，是因为有一个消息队列(一般是调用第一个user32相关函数时候，系统自动创建的)，然后UI线程里面有很多窗口，这些窗口也都是基于消息驱动的，所以光有消息队列还不够，还需要消息泵，来从队列里面获取和分发消息到指定窗口，所谓的消息泵就是我们所说的消息循环了，最经典的就是下面的：
```
while(GetMessage(msg)){
	::TranslateMessage(&m_msg);
	::DispatchMessage(&m_msg);
}
```
我们只要保证UI线程里面有一个消息循环存在，那么这个线程就不会被阻塞，而阻塞的情况有两种：一种是通过内核调用到了内核态去等待事件，比如WaitForSingleObject等，还有一种是在某处消息响应函数里面，进入了死循环，导致无法回到最近的消息循环，也算是被阻塞了

模态对话框和窗口拖动时候，容易给人造成误解，就是在调用完成之前，没有返回到主消息循环，但这个时候并不代表卡死，系统在这些调用里面，开了自己的消息循环，主要就是用来模拟一个同步调用，但是UI线程还是有消息泵存在，所以不是被阻塞，这个线程的窗口还都可以正常收到消息，只是当前的消息循环换了一个而已

但是如果你在主消息循环里面做了额外的事情，比如PreTranslateMessage，那么在进入别的消息循环还没有返回之前，这些是执行不到的，容易造成“阻塞”的假象。解决办法就是基于消息，比如某个后台窗口的Timer，因为只要UI线程不被阻塞，那么这些消息肯定可以收到的
